(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{476:function(t,a,e){"use strict";e.r(a);var s=e(1),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"melodot-如何工作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#melodot-如何工作"}},[t._v("#")]),t._v(" Melodot 如何工作")]),t._v(" "),e("h2",{attrs:{id:"数据可用性抽样"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据可用性抽样"}},[t._v("#")]),t._v(" 数据可用性抽样")]),t._v(" "),e("p",[t._v("解耦后数据可用性层，需要确保任何使用它的模块都可以低成本地对数据可用性达成一致。这要求数据可用性层并不是“它在多大程度上是安全的”，而是“不引入额外假设”。Melodot 通过将数据编码为 2D 矩阵后，采用可用性抽样来实现这一点。具体来说，数据在行方向上和列方向上被扩展到两倍大小，其中任意行和列的任意一半的数据都可以恢复出原始数据。因此你只需要成功随机抽样一个数据块，就表明该数据可用性概率为 75%，多次采样后得到足够的可用性信心保证。")]),t._v(" "),e("h2",{attrs:{id:"多项式承诺"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多项式承诺"}},[t._v("#")]),t._v(" 多项式承诺")]),t._v(" "),e("p",[t._v("Melodot 使用多项式承诺来确保数据被正确编码。原始的数据可用性层方案采用默克尔编码，要求一个强大的全节点获取所有数据并生成和传播欺诈证明，我们避免了这一点，这不仅降低了效率，同时也引入了额外的假设。")]),t._v(" "),e("p",[t._v("具体来说，我们在行方向上生成 KZG 承诺。每 "),e("code",[t._v("l")]),t._v(" 个数据块被编码为片段，它们共用一个相同的证明，采样同样是基于片段进行的，这是为了提高采样的效率。")]),t._v(" "),e("p",[t._v("同时，我们在设计中保持兼容性，并持续研究其他替代密码学解决方案，例如 STARK、FRI、IPA 等方面的最新进展。")]),t._v(" "),e("h2",{attrs:{id:"最少诚实采样者"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最少诚实采样者"}},[t._v("#")]),t._v(" 最少诚实采样者")]),t._v(" "),e("p",[t._v("当网络中诚实采样者数量不足时，数据提供者只释放一部数据，它们足以使得采样者以为数据是可用的，随后数据提供者隐藏剩余的数据，导致数据无法恢复。这要求网络中存在足够多的诚实采样者，通过抽样将数据饱和地存储于点对点网络。因此可以认为系统吞吐量取决于诚实采样者数量。")]),t._v(" "),e("p",[t._v("我们很难观察和预测每个区块的采样者数量。因为轻客户端更关心于自己相关的数据，出于经济上的考量，轻客户端不对没有自己感兴趣的区块采样，这导致每个区块的具有不同数量的采样者，他们的差别可能非常大。因此，”系统吞吐量随着采样者数量的增长而增长“是一个需要谨慎对待的结论。")]),t._v(" "),e("p",[t._v("Melodot 通过引入农民来解决该问题，农民被激励为采样足够数量的可用性数据、保存数据至一定时长、为点对点网络提供带宽。我们可以从奖励的发放情况获取活跃农民的数量，从而安全确定系统吞吐量。")]),t._v(" "),e("h2",{attrs:{id:"分布式生成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式生成"}},[t._v("#")]),t._v(" 分布式生成")]),t._v(" "),e("p",[t._v("原始的数据可用性层在提议阶段，提议者单独对全部数据进行昂贵的多项式承诺和 RS 编码，需要非常高的带宽和性能。这不仅加深了系统的中心化程度，也会成为系统吞吐量的瓶颈。")]),t._v(" "),e("p",[t._v("在数据验证和存储阶段，验证者需要下载大量的数据（甚至全部数据），当数据块无效还需要进行重构，这大幅增加了验证者的负载。系统为了确保一切符合期望，需要额外的机制，让臃肿的验证者雪上加霜。")]),t._v(" "),e("p",[t._v("在 Melodot 中，验证者更像一个轻客户端，他们无须进行昂贵的编码。数据在列方向扩展的任务交给不同的农民，他们首先从区块头中获取原始的承诺，并扩展到双倍大小。之后农民获取自己所需的列，将数据块和证明扩展到双倍大小，这是通过直接扩展实现的，不需要实际进行多项式承诺类的计算。农民需要从这些数据中寻找“彩票”，以获取奖励。分布式生成完成后，点对点网络中应当已经包含了 2D 纠删码后的所有数据块。需要注意的是，在 worst case 中，所有农民全部掉线，这将导致最终的采样失败，数据不可用，因此农民并不影响系统安全性。")]),t._v(" "),e("p",[t._v("分布式生成对系统吞吐量是至关重要的，我们实际做到了系统吞吐量随着农民的数量增加而增加，并且建立在不牺牲去中心化的基础上。")]),t._v(" "),e("h2",{attrs:{id:"pospace"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pospace"}},[t._v("#")]),t._v(" PoSpace")]),t._v(" "),e("p",[t._v("Melodot 通过 Chia 风格的 PoSpace 来确保农民诚实地存储了数据，它需要农民一次性的完成一次被称为 “P盘” 的步骤，以承诺一定大小的硬盘空间。在这之后农民可以在此硬盘上耕种相当长的时间，并且对资源的消耗非常小，允许消费级的个人电脑加入到网络中，这是一种去中心化程度非常高的激励机制。")]),t._v(" "),e("p",[t._v("在正式版本中，用户可自行设置数据存储的期限，过期的数据将无法获取奖励，农民需要定期更新数据。用户将从农民为主的分布式存储中可靠地获取可用性数据。在最终版本中，我们引入针锋相对的技术，激励农民更多地参与数据交换。")])])}),[],!1,null,null,null);a.default=v.exports}}]);